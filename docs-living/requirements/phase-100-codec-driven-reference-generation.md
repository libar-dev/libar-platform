# ✅ Codec Driven Reference Generation

**Purpose:** Detailed requirements for the Codec Driven Reference Generation feature

---

## Overview

| Property       | Value                                        |
| -------------- | -------------------------------------------- |
| Status         | completed                                    |
| Product Area   | DeliveryProcess                              |
| Business Value | eliminate recipe files via codec composition |
| Phase          | 100                                          |

## Description

**Problem:**
Reference documentation is specified via 11 recipe `.feature` files in
`delivery-process/recipes/`. Each recipe contains a Source Mapping table
(static configuration) and Rule blocks (durable content). But recipes
are configuration masquerading as feature files — no scenarios execute,
no BDD benefit exists. The Source Mapping is static and the Rule blocks
are durable knowledge that belongs in decision records.

**Solution:**
Replace recipe files with a parameterized `ReferenceDocumentCodec` that
composes reference documents from convention-tagged decision records,
TypeScript shape extractions, and behavior spec content. The Source Mapping
becomes a TypeScript config object registered in the existing `GeneratorRegistry`.
Recipe Rule blocks migrate to decision records tagged `@libar-docs-convention`.

**Business Value:**

| Benefit                                | Impact                                              |
| -------------------------------------- | --------------------------------------------------- |
| Eliminate 11 recipe files              | Less surface area, no parallel config format        |
| Reuse existing codec infrastructure    | z.codec(), DetailLevel, DocumentGenerator           |
| Convention content in decision records | Durable, queryable, tagged — not trapped in recipes |
| Dual output from single config         | DetailLevel controls docs/ vs \_claude-md/ output   |
| Codec IS the config                    | No external configuration files to maintain         |

**Architecture:**

| Component                  | Role                                                                  | Status             |
| -------------------------- | --------------------------------------------------------------------- | ------------------ |
| ReferenceDocConfig         | TypeScript config per document type                                   | New                |
| ReferenceDocumentCodec     | Parameterized codec composing from conventions + shapes + behaviors   | New                |
| ConventionExtractor        | Filters MasterDataset for convention-tagged decision records          | New                |
| ReferenceDocGenerator      | Implements DocumentGenerator directly, registers in GeneratorRegistry | New                |
| @libar-docs-convention tag | CSV tag on decision records                                           | New taxonomy entry |
| Decision record migration  | Recipe Rule blocks → decision records                                 | Migration          |

**What Stays, What Goes:**

| Current                                  | After                                          |
| ---------------------------------------- | ---------------------------------------------- |
| 11 recipe .feature files (recipes/)      | Deleted                                        |
| Recipe Source Mapping tables             | ReferenceDocConfig objects in TypeScript       |
| Recipe Rule blocks (durable content)     | Decision records tagged @libar-docs-convention |
| Recipe @libar-docs-claude-md-section tag | ReferenceDocConfig.claudeMdSection field       |
| docs-generated/ staging area             | Direct output to \_claude-md/ and docs/        |
| Manual \_claude-md/ modules              | Generated by codec at summary DetailLevel      |

## Acceptance Criteria

**Generate process guard reference at standard detail level**

- Given a ReferenceDocConfig for "Process Guard"
- And convention-tagged decision records exist for "fsm-rules"
- And TypeScript shapes are extracted from "src/lint/\*.ts"
- When the reference codec decodes the MasterDataset
- Then a RenderableDocument is produced with Process Guard content
- And sections include convention content, API types, and validation rules

**Generate process guard reference at summary detail level**

- Given a ReferenceDocConfig for "Process Guard" with detailLevel "summary"
- When the reference codec decodes the MasterDataset
- Then the output uses tables over prose
- And type names are listed without full definitions
- And no duplicate sections appear
- And output is under 100 lines

**Extract conventions by tag value**

- Given ADR-006 is tagged with "@libar-docs-convention:fsm-rules"
- And ADR-004 is tagged with "@libar-docs-convention:testing-policy"
- When extracting conventions for "fsm-rules"
- Then only ADR-006 Rule block content is returned
- And ADR-004 content is not included

**Convention content preserves Rule block structure**

- Given a decision record with Rule blocks containing tables and context
- When extracting convention content
- Then tables are preserved as structured data
- And Invariant/Rationale/Verified-by metadata is preserved

**No conventions found for requested tag values**

- Given a MasterDataset with no decision records tagged "fsm-rules"
- When the reference codec decodes for "Process Guard"
- Then the output omits the conventions section
- And the document is still valid with shape and behavior content

**No shape sources match any pattern file paths**

- Given a ReferenceDocConfig with shapeSources "src/nonexistent/\*.ts"
- When the reference codec decodes the MasterDataset
- Then the output omits the type definitions section
- And no error is raised

**Convention tag matches multiple decision records**

- Given ADR-006 and ADR-012 are both tagged "fsm-rules"
- When extracting conventions for "fsm-rules"
- Then both decision records contribute Rule block content
- And content is ordered by source decision record

**Dual output generation**

- Given a ReferenceDocConfig with claudeMdSection "validation"
- When the reference generator runs
- Then "docs/PROCESS-GUARD-REFERENCE.md" is generated at "detailed" level
- And "\_claude-md/validation/process-guard.md" is generated at "summary" level

**Summary compaction quality**

- Given a reference codec output at "summary" detail level
- Then the output follows modular-claude-md conventions
- And headings start at H3 level
- And tables are preferred over prose
- And total output is under 100 lines

**Reference generators appear in available generators list**

- Given reference generators are registered
- When querying GeneratorRegistry.available()
- Then "process-guard-reference" is listed
- And "session-guides-reference" is listed
- And all 11 reference types are available

**CLI invocation generates reference docs**

- Given the generate-docs CLI
- When running with "--generators process-guard-reference"
- Then dual output is produced for process guard

**Convention tag is registered in taxonomy**

- Given the tag registry
- When checking for "@libar-docs-convention"
- Then it exists with format "csv"
- And it accepts the defined convention values

**Recipe Rule block content preserved in decision record**

- Given recipe "process-guard-reference.feature" has Rule "Escape Hatches"
- And the Rule contains a table with "Situation", "Solution", "Example" columns
- When the Rule is migrated to a decision record tagged "fsm-rules"
- Then the decision record Rule block contains the same table
- And Invariant/Rationale metadata is preserved

## Business Rules

**Reference documents are generated by a parameterized codec**

**Invariant:** Each reference document type is a configuration object, not a
separate codec class. One `createReferenceCodec(config)` factory serves all
11 document types.

    **Rationale:** 11 separate codec classes would just be reimplementing recipes
    in TypeScript. A parameterized codec keeps the configuration declarative
    while the composition logic is shared.

_Verified by: Generate process guard reference at standard detail level, Generate process guard reference at summary detail level_

**Convention content is extracted from tagged decision records**

**Invariant:** Decision records tagged with `@libar-docs-convention` are the
source of truth for durable reference content. The extractor filters by
convention tag value and extracts Rule block content.

    **Rationale:** Recipe Rule blocks contain durable knowledge (tables, context,
    rationale) that belongs in decision records — permanent, queryable, tagged.
    Decision records are already extracted as patterns in MasterDataset.

_Verified by: Extract conventions by tag value, Convention content preserves Rule block structure_

**Reference codec handles missing or empty sources gracefully**

**Invariant:** When convention tags, shape sources, or behavior tags match
zero items in the MasterDataset, the codec produces a valid but sparse
document rather than failing.

    **Rationale:** Not all reference configs will have all three source types
    populated. Some references have no shapes (Session Guides), others have
    no conventions yet (before migration). Graceful degradation is required.

_Verified by: No conventions found for requested tag values, No shape sources match any pattern file paths, Convention tag matches multiple decision records_

**Each reference generator produces dual output via DetailLevel**

**Invariant:** A single ReferenceDocConfig drives both the detailed human
reference (docs/) and the compact AI context (\_claude-md/). The
ReferenceDocGenerator invokes the codec factory twice with different
DetailLevel values, following the DecisionDocGeneratorImpl multi-level pattern.

    **Rationale:** The recipe system declared dual targets in its Target Documents
    table. The generator approach achieves the same by running the same codec with
    different options. No separate configuration needed.

    **Verified by:** Dual output generation, Summary compaction quality

_Verified by: Dual output generation, Summary compaction quality_

**Reference generators are discovered via the existing registry**

**Invariant:** Reference generators register themselves in the GeneratorRegistry
by implementing DocumentGenerator directly, following the DecisionDocGeneratorImpl
precedent. DOCUMENT_TYPES is `as const` and not dynamically extensible, so the
CodecBasedGenerator adapter is not used.

    **Rationale:** DecisionDocGeneratorImpl already demonstrates this pattern:
    direct DocumentGenerator implementation, dual output, factory function registration.
    No changes needed to generate.ts, codec-based.ts, or registry.ts.

_Verified by: Reference generators appear in available generators list, CLI invocation generates reference docs_

**Convention tag values classify decision records by topic**

**Invariant:** The `@libar-docs-convention` tag uses CSV format with defined
values. Each value maps to a knowledge domain that reference codecs consume.

    **Rationale:** Convention tags are orthogonal to existing `@libar-docs-adr-category`
    (which is too coarse — "process" covers both testing policy and FSM rules).

    | Value | Knowledge Domain | Reference Docs That Consume |
    | --- | --- | --- |
    | testing-policy | Test safety, Gherkin-only policy | GherkinPatternsReference, ValidationReference |
    | fsm-rules | FSM transitions, protection levels | ProcessGuardReference, SessionGuidesReference |
    | cli-patterns | CLI conventions, arg parsing | InstructionsReference, ConfigurationReference |
    | output-format | Text vs markdown, codec patterns | ArchitectureReference |
    | pattern-naming | Pattern identifiers, @implements | InstructionsReference, MethodologyReference |
    | session-workflow | Session types, handoff, stubs | SessionGuidesReference, MethodologyReference |
    | config-presets | Presets, tag prefixes, RegexBuilders | ConfigurationReference |
    | annotation-system | Tag formats, dual-source, opt-in | InstructionsReference, TaxonomyReference |
    | pipeline-architecture | Four-stage pipeline, codecs, MasterDataset | ArchitectureReference |
    | publishing | Publishing strategy, versioning | PublishingReference |
    | doc-generation | Recipes, generators, dual output | IndexReference |

_Verified by: Convention tag is registered in taxonomy_

**Recipe Rule blocks are migrated to convention-tagged decision records**

**Invariant:** Every Rule block from the 11 recipe .feature files is
preserved as a Rule block in a decision record tagged with the appropriate
`@libar-docs-convention` value. No durable content is lost during migration.

    **Rationale:** Recipe Rule blocks contain tables, rationale, and context
    that are the authoritative reference for the delivery process. Migration
    must be lossless.

_Verified by: Recipe Rule block content preserved in decision record_

---

[← Back to Product Requirements](../PRODUCT-REQUIREMENTS.md)
