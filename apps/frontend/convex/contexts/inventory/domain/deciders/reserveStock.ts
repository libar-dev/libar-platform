/**
 * ReserveStock decider - pure decision logic.
 *
 * Validates that stock can be reserved for an order and produces StockReserved event.
 * On business failure (insufficient stock), produces ReservationFailed event.
 *
 * HYBRID PATTERN:
 * - This decider receives pre-loaded product state from the handler
 * - Handler coordinates loading multiple products and applying updates
 * - Decider remains pure (no I/O)
 *
 * NOTE: The stateUpdate is undefined because the handler needs to coordinate
 * updates to multiple InventoryCMS records and create a new ReservationCMS.
 */

import type { DeciderOutput, Decider } from "@libar-dev/platform-core/decider";
import { success, failed, rejected } from "@libar-dev/platform-core/decider";
import {
  validateReservationItems,
  checkStockAvailability,
  InventoryInvariantError,
} from "../invariants.js";
import { DEFAULT_RESERVATION_TTL_MS } from "../reservation.js";
import type {
  InventoryCMS,
  ReserveStockInput,
  ReserveStockData,
  StockReservedEvent,
  ReservationFailedEvent,
  FailedItem,
  DeciderContext,
} from "./types.js";

/**
 * Decide whether to reserve stock for an order.
 *
 * Pure function: no I/O, no side effects.
 *
 * IMPORTANT: This decider receives pre-loaded product states as a Map.
 * The handler is responsible for loading the products before calling this.
 *
 * Invariants:
 * - Items array must not be empty
 * - Each item must have valid productId and positive quantity
 * - All products must have sufficient available stock (all-or-nothing)
 * - reservationId must be pre-generated by handler (ensures decider purity)
 *
 * @param products - Map of productId -> InventoryCMS (pre-loaded by handler)
 * @param command - ReserveStock command input
 * @param context - Decider context (timestamp, IDs)
 * @returns DeciderOutput with StockReserved event, or failed with ReservationFailed event
 */
export function decideReserveStock(
  products: Map<string, InventoryCMS>,
  command: ReserveStockInput,
  context: DeciderContext
): DeciderOutput<StockReservedEvent | ReservationFailedEvent, ReserveStockData, undefined> {
  // Validate items format (throws on invalid)
  try {
    validateReservationItems(command.items);
  } catch (error) {
    // Propagate proper error code from InventoryInvariantError
    if (error instanceof InventoryInvariantError) {
      return rejected(error.code, error.message, error.context);
    }
    return rejected(
      "EMPTY_RESERVATION",
      error instanceof Error ? error.message : "Invalid reservation items"
    );
  }

  // Check all products have sufficient stock
  const failedItems: FailedItem[] = [];

  for (const item of command.items) {
    const product = products.get(item.productId);

    // Product not found or insufficient stock
    if (!product) {
      failedItems.push({
        productId: item.productId,
        requestedQuantity: item.quantity,
        availableQuantity: 0,
      });
      continue;
    }

    const availability = checkStockAvailability(product, item.quantity);
    if (!availability.available) {
      failedItems.push({
        productId: item.productId,
        requestedQuantity: item.quantity,
        availableQuantity: product.availableQuantity,
      });
    }
  }

  // Business failure - emit ReservationFailed event
  if (failedItems.length > 0) {
    return failed<ReservationFailedEvent>(
      "INSUFFICIENT_STOCK",
      {
        eventType: "ReservationFailed" as const,
        payload: {
          orderId: command.orderId,
          reason: "Insufficient stock",
          failedItems,
        },
      },
      {
        orderId: command.orderId,
        failedItems,
      }
    );
  }

  // All items have sufficient stock - create reservation
  // reservationId comes from command input (handler generates it)
  const { reservationId } = command;
  const expiresAt = context.now + DEFAULT_RESERVATION_TTL_MS;

  return success({
    data: {
      reservationId,
      orderId: command.orderId,
      expiresAt,
      itemCount: command.items.length,
    },
    event: {
      eventType: "StockReserved" as const,
      payload: {
        reservationId,
        orderId: command.orderId,
        items: command.items,
        expiresAt,
      },
    },
    // stateUpdate is undefined - handler coordinates multi-entity updates
    stateUpdate: undefined,
  });
}

/**
 * Evolve state by applying StockReserved event.
 *
 * NOTE: For the hybrid pattern, this evolve function operates on a single
 * InventoryCMS to update stock levels. Call once per product in the reservation.
 *
 * @param state - Current InventoryCMS state
 * @param event - StockReserved event
 * @param productId - Which product to evolve (needed since event contains multiple items)
 * @returns New InventoryCMS state with updated quantities
 */
export function evolveReserveStockForProduct(
  state: InventoryCMS,
  event: StockReservedEvent,
  productId: string
): InventoryCMS {
  // Find the reserved quantity for this product
  const item = event.payload.items.find((i) => i.productId === productId);
  if (!item) {
    // Product not in this reservation - no change
    return state;
  }

  return {
    ...state,
    availableQuantity: state.availableQuantity - item.quantity,
    reservedQuantity: state.reservedQuantity + item.quantity,
  };
}

/**
 * Evolve state for ReservationFailed event.
 *
 * No state changes for failed reservations - stock levels unchanged.
 */
export function evolveReservationFailed(
  state: InventoryCMS,
  _event: ReservationFailedEvent
): InventoryCMS {
  return state;
}

/**
 * Full ReserveStock Decider combining decide and evolve.
 *
 * HYBRID DECIDER PATTERN:
 * This is a hybrid decider for multi-entity operations. The `evolve` function
 * intentionally returns the Map unchanged because:
 *
 * 1. Individual product state updates use `evolveReserveStockForProduct()`
 * 2. Reservation state is created directly in the handler
 * 3. The aggregate Map cannot be meaningfully evolved from a single event
 *
 * For unit testing and projection rebuilding, use these functions directly:
 * - `evolveReserveStockForProduct(state, event, productId)` - per-product evolution
 * - `evolveReservationFailed(state, event)` - no-op for failed reservations
 *
 * @see evolveReserveStockForProduct for testing individual product state changes
 * @see Phase 16 DCB for future pure multi-entity decider support
 */
export const reserveStockDecider: Decider<
  Map<string, InventoryCMS>,
  ReserveStockInput,
  StockReservedEvent | ReservationFailedEvent,
  ReserveStockData,
  undefined
> = {
  decide: decideReserveStock,
  // Hybrid pattern: evolve at aggregate level is no-op.
  // Use evolveReserveStockForProduct() per product for actual state evolution.
  evolve: (state: Map<string, InventoryCMS>) => state,
};
