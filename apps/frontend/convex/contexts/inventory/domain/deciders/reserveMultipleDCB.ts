/**
 * ReserveMultipleDCB decider - pure DCB decision logic for multi-product reservation.
 *
 * Demonstrates Dynamic Consistency Boundaries (DCB) pattern from Phase 16.
 * Unlike the hybrid `reserveStock.ts`, this decider:
 * - Receives `DCBAggregatedState<InventoryCMS>` (all products in scope)
 * - Returns `DCBStateUpdates<InventoryStateUpdate>` (updates per entity)
 * - Enables atomic cross-entity invariant validation via executeWithDCB
 *
 * @libar-docs
 * @libar-docs-pattern ExampleAppModernization
 * @libar-docs-status roadmap
 * @libar-docs-uses DynamicConsistencyBoundaries, ReservationPattern
 *
 * @since Phase 23 (Example App Modernization - Rule 1)
 */

import type { DeciderOutput } from "@libar-dev/platform-core/decider";
import { success, failed, rejected } from "@libar-dev/platform-core/decider";
import type { DCBDecider } from "@libar-dev/platform-core/dcb";
import {
  validateReservationItems,
  checkStockAvailability,
  InventoryInvariantError,
} from "../invariants.js";
import { DEFAULT_RESERVATION_TTL_MS } from "../reservation.js";
import type {
  InventoryCMS,
  ReserveMultipleDCBCommand,
  ReserveStockData,
  StockReservedEvent,
  ReservationFailedEvent,
  FailedItem,
  DeciderContext,
  DCBAggregatedState,
  DCBStateUpdates,
  InventoryStateUpdate,
} from "./types.js";

/**
 * DCB decider for multi-product reservation.
 *
 * Pure function: no I/O, no side effects.
 *
 * This decider receives aggregated state from all products in the scope,
 * enabling atomic cross-entity invariant validation. All products must
 * have sufficient stock for the reservation to succeed (all-or-nothing).
 *
 * ## Key Differences from Hybrid Decider (`reserveStock.ts`)
 *
 * | Aspect | Hybrid | DCB |
 * |--------|--------|-----|
 * | Input state | `Map<string, InventoryCMS>` | `DCBAggregatedState<InventoryCMS>` |
 * | State access | `products.get(id)` | `state.entities.get(id)?.cms` |
 * | Output updates | `undefined` (handler coordinates) | `DCBStateUpdates<Update>` |
 * | Atomicity | Handler-managed | Built-in via executeWithDCB |
 *
 * ## Invariants
 *
 * - Items array must not be empty
 * - Each item must have valid productId and positive quantity
 * - All products must exist (executeWithDCB pre-validates this)
 * - All products must have sufficient available stock (all-or-nothing)
 * - reservationId must be pre-generated by handler (ensures decider purity)
 *
 * @param state - DCB aggregated state with all products in scope
 * @param command - ReserveMultipleDCB command with orderId, items, reservationId
 * @param context - Decider context (timestamp, IDs)
 * @returns DeciderOutput with success/failed/rejected and state updates
 */
export function decideReserveMultipleDCB(
  state: DCBAggregatedState<InventoryCMS>,
  command: ReserveMultipleDCBCommand,
  context: DeciderContext
): DeciderOutput<
  StockReservedEvent | ReservationFailedEvent,
  ReserveStockData,
  DCBStateUpdates<InventoryStateUpdate>
> {
  // Validate items format (throws on invalid)
  try {
    validateReservationItems(command.items);
  } catch (error) {
    // Propagate proper error code from InventoryInvariantError
    if (error instanceof InventoryInvariantError) {
      return rejected(error.code, error.message, error.context);
    }
    return rejected(
      "EMPTY_RESERVATION",
      error instanceof Error ? error.message : "Invalid reservation items"
    );
  }

  // Check all products have sufficient stock
  const failedItems: FailedItem[] = [];

  for (const item of command.items) {
    const entityState = state.entities.get(item.productId);

    // Product not found in aggregated state
    // Note: executeWithDCB pre-validates entity existence, but we handle it anyway
    if (!entityState) {
      failedItems.push({
        productId: item.productId,
        requestedQuantity: item.quantity,
        availableQuantity: 0,
      });
      continue;
    }

    const product = entityState.cms;
    const availability = checkStockAvailability(product, item.quantity);
    if (!availability.available) {
      failedItems.push({
        productId: item.productId,
        requestedQuantity: item.quantity,
        availableQuantity: product.availableQuantity,
      });
    }
  }

  // Business failure - emit ReservationFailed event
  if (failedItems.length > 0) {
    return failed<ReservationFailedEvent>(
      "INSUFFICIENT_STOCK",
      {
        eventType: "ReservationFailed" as const,
        payload: {
          orderId: command.orderId,
          reason: "Insufficient stock",
          failedItems,
        },
      },
      {
        orderId: command.orderId,
        failedItems,
      }
    );
  }

  // All items have sufficient stock - build state updates
  const { reservationId, orderId, items } = command;
  const expiresAt = context.now + DEFAULT_RESERVATION_TTL_MS;

  // Build DCBStateUpdates: Map<productId, InventoryStateUpdate>
  const stateUpdates: DCBStateUpdates<InventoryStateUpdate> = new Map();

  for (const item of items) {
    const entityState = state.entities.get(item.productId);
    if (!entityState) continue; // Already validated above

    const product = entityState.cms;
    stateUpdates.set(item.productId, {
      availableQuantity: product.availableQuantity - item.quantity,
      reservedQuantity: product.reservedQuantity + item.quantity,
    });
  }

  return success({
    data: {
      reservationId,
      orderId,
      expiresAt,
      itemCount: items.length,
    },
    event: {
      eventType: "StockReserved" as const,
      payload: {
        reservationId,
        orderId,
        items,
        expiresAt,
      },
    },
    stateUpdate: stateUpdates,
  });
}

/**
 * DCB Decider type alias for multi-product reservation.
 *
 * Use this type when passing the decider to executeWithDCB:
 *
 * ```typescript
 * const result = await executeWithDCB(ctx, {
 *   // ...
 *   decider: reserveMultipleDCBDecider,
 *   // ...
 * });
 * ```
 */
export const reserveMultipleDCBDecider: DCBDecider<
  InventoryCMS,
  ReserveMultipleDCBCommand,
  StockReservedEvent | ReservationFailedEvent,
  ReserveStockData,
  InventoryStateUpdate
> = decideReserveMultipleDCB;
