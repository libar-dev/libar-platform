/**
 * Step Definitions Stub Template
 *
 * Purpose: Template for creating step definitions for executable specs
 * Usage: Planning+Design sessions create these as planning artifacts
 * Output: deps/libar-dev-packages/packages/{package}/tests/planning-stubs/{path}/{pattern}.steps.ts
 *
 * IMPORTANT: Planning stubs go to `tests/planning-stubs/` (excluded from vitest).
 * During implementation, move to `tests/steps/` and replace throw statements.
 *
 * See: delivery-process/docs/PLANNING-DESIGN-SESSION-GUIDE.md for complete workflow
 *
 * @libar-docs
 * @libar-docs-implements {{PatternName}}
 */

import { loadFeature, describeFeature } from "@amiceli/vitest-cucumber";
import { expect } from "vitest";

// Import the modules under test
// import { ... } from "../../src/index.js";

// ============================================================================
// Test Types (adjust based on feature requirements)
// ============================================================================

interface TestContext {
  // Add context-specific types
}

// ============================================================================
// Test State
// ============================================================================

interface ScenarioState {
  context: TestContext | null;
  result: unknown;
  error: Error | null;
}

let state: ScenarioState | null = null;

function initState(): ScenarioState {
  return {
    context: null,
    result: undefined,
    error: null,
  };
}

// ============================================================================
// Feature Tests
// ============================================================================

const feature = await loadFeature("tests/features/behavior/{{feature-name}}.feature");

// CRITICAL: When features use Rule: keyword, use Rule() + RuleScenario() pattern
// DO NOT use Scenario() directly - it causes FeatureUnknownScenarioError
describeFeature(feature, ({ Background, Rule, BeforeEachScenario, AfterEachScenario }) => {
  // Reset state before/after each scenario for isolation
  BeforeEachScenario(() => {
    state = initState();
  });

  AfterEachScenario(() => {
    state = null;
  });

  // ==========================================================================
  // Background (runs before each scenario)
  // ==========================================================================

  Background(({ Given }) => {
    Given("the test environment is initialized", async () => {
      // state already initialized by BeforeEachScenario
      // Add common setup logic here
      throw new Error("Not implemented: background setup");
    });
  });

  // ==========================================================================
  // Rule 1: {{Rule name from feature file}}
  // ==========================================================================

  Rule("{{Rule name from feature file}}", ({ RuleScenario }) => {
    RuleScenario("{{Validates first concept - happy path}}", ({ Given, When, Then }) => {
      Given("{{precondition with specific example}}", async () => {
        // Setup precondition
        throw new Error("Not implemented: precondition");
      });

      When("{{action is performed}}", async () => {
        // Execute action
        throw new Error("Not implemented: action");
      });

      Then("{{expected outcome}}", async () => {
        // Verify outcome
        expect(state!.result).toBeDefined();
        throw new Error("Not implemented: outcome assertion");
      });
    });

    RuleScenario("{{Validates first concept - error case}}", ({ Given, When, Then }) => {
      Given("{{invalid precondition}}", async () => {
        // Setup invalid precondition
        throw new Error("Not implemented: invalid precondition");
      });

      When("{{action is attempted}}", async () => {
        // Execute action, capture error
        try {
          // action that should fail
          throw new Error("Not implemented: action that should fail");
        } catch (error) {
          state!.error = error as Error;
        }
      });

      Then("{{expected rejection with error code}}", async () => {
        expect(state!.error).toBeDefined();
        // expect(state!.error!.message).toContain("ERROR_CODE");
        throw new Error("Not implemented: error assertion");
      });
    });
  });

  // ==========================================================================
  // Rule 2: {{Second rule name from feature file}}
  // ==========================================================================

  Rule("{{Second rule name from feature file}}", ({ RuleScenario }) => {
    RuleScenario("{{Validates second concept}}", ({ Given, When, Then }) => {
      Given("{{setup}}", async () => {
        // Setup
        throw new Error("Not implemented: setup");
      });

      When("{{action}}", async () => {
        // Execute
        throw new Error("Not implemented: action");
      });

      Then("{{outcome}}", async () => {
        // Verify
        throw new Error("Not implemented: outcome");
      });
    });
  });

  // ==========================================================================
  // Rule 3: {{Edge case rule - if using ScenarioOutline}}
  // ==========================================================================
  //
  // NOTE: For ScenarioOutline with Examples table, use RuleScenarioOutline:
  //
  // Rule("{{Edge case rule}}", ({ RuleScenarioOutline }) => {
  //   RuleScenarioOutline(
  //     "{{Pattern with variations}}",
  //     ({ Given, When, Then }, variables: { variant: string; expected: string }) => {
  //       Given('a "<variant>" configuration', async () => {
  //         // Setup based on variables.variant
  //       });
  //
  //       When("{{action}} is performed", async () => {
  //         // Execute action
  //       });
  //
  //       Then('the result should be "<expected>"', async () => {
  //         expect(state!.result).toBe(variables.expected);
  //       });
  //     }
  //   );
  // });
});

// =============================================================================
// CHECKLIST: Before committing, verify:
// =============================================================================
// [ ] All Rule() names match the Rule: names in .feature file EXACTLY
// [ ] All RuleScenario() names match Scenario: names EXACTLY
// [ ] State is reset before/after each scenario
// [ ] Background steps are shared correctly
// [ ] ScenarioOutline uses variables parameter correctly
// [ ] File is in tests/planning-stubs/ (excluded from vitest)
// [ ] When implementing, move to tests/steps/ and replace throw statements
// [ ] Tests pass: pnpm test --filter @libar-dev/{package}
