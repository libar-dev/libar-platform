@libar-docs
@libar-docs-release:vNEXT
@process-enhancements
@libar-docs-pattern:CodecDrivenReferenceGeneration
@libar-docs-status:completed
@libar-docs-phase:100
@libar-docs-quarter:Q1-2026
@libar-docs-product-area:DeliveryProcess
@libar-docs-business-value:eliminate-recipe-files-via-codec-composition
@libar-docs-priority:high
@libar-docs-executable-specs:deps-packages/delivery-process/tests/features/behavior/reference-generation
@libar-docs-unlock-reason:Fix-deliverable-status-Done-to-canonical-complete
Feature: Codec-Driven Reference Generation

  **Problem:**
  Reference documentation is specified via 11 recipe `.feature` files in
  `delivery-process/recipes/`. Each recipe contains a Source Mapping table
  (static configuration) and Rule blocks (durable content). But recipes
  are configuration masquerading as feature files — no scenarios execute,
  no BDD benefit exists. The Source Mapping is static and the Rule blocks
  are durable knowledge that belongs in decision records.

  **Solution:**
  Replace recipe files with a parameterized `ReferenceDocumentCodec` that
  composes reference documents from convention-tagged decision records,
  TypeScript shape extractions, and behavior spec content. The Source Mapping
  becomes a TypeScript config object registered in the existing `GeneratorRegistry`.
  Recipe Rule blocks migrate to decision records tagged `@libar-docs-convention`.

  **Business Value:**

  | Benefit | Impact |
  | --- | --- |
  | Eliminate 11 recipe files | Less surface area, no parallel config format |
  | Reuse existing codec infrastructure | z.codec(), DetailLevel, DocumentGenerator |
  | Convention content in decision records | Durable, queryable, tagged — not trapped in recipes |
  | Dual output from single config | DetailLevel controls docs/ vs _claude-md/ output |
  | Codec IS the config | No external configuration files to maintain |

  **Architecture:**

  | Component | Role | Status |
  | --- | --- | --- |
  | ReferenceDocConfig | TypeScript config per document type | New |
  | ReferenceDocumentCodec | Parameterized codec composing from conventions + shapes + behaviors | New |
  | ConventionExtractor | Filters MasterDataset for convention-tagged decision records | New |
  | ReferenceDocGenerator | Implements DocumentGenerator directly, registers in GeneratorRegistry | New |
  | @libar-docs-convention tag | CSV tag on decision records | New taxonomy entry |
  | Decision record migration | Recipe Rule blocks → decision records | Migration |

  **What Stays, What Goes:**

  | Current | After |
  | --- | --- |
  | 11 recipe .feature files (recipes/) | Deleted |
  | Recipe Source Mapping tables | ReferenceDocConfig objects in TypeScript |
  | Recipe Rule blocks (durable content) | Decision records tagged @libar-docs-convention |
  | Recipe @libar-docs-claude-md-section tag | ReferenceDocConfig.claudeMdSection field |
  | docs-generated/ staging area | Direct output to _claude-md/ and docs/ |
  | Manual _claude-md/ modules | Generated by codec at summary DetailLevel |

  Background: Deliverables
    Given the following deliverables:
      | Deliverable | Status | Tests | Location |
      | ReferenceDocConfig type definition | complete | Yes | src/renderable/codecs/types/reference.ts |
      | ConventionExtractor utility | complete | Yes | src/renderable/codecs/convention-extractor.ts |
      | ReferenceDocumentCodec factory | complete | Yes | src/renderable/codecs/reference.ts |
      | ReferenceDocGenerator (DocumentGenerator impl) | complete | Yes | src/generators/built-in/reference-generators.ts |
      | @libar-docs-convention tag in registry | complete | No | upstream: deps-packages/delivery-process/src/taxonomy/ |
      | Convention values in taxonomy | complete | No | src/taxonomy/conventions.ts |
      | Decision record migration (existing ADRs) | complete | No | delivery-process/decisions/ |
      | Decision record creation (new from recipe Rules) | complete | No | delivery-process/decisions/ |
      | Recipe directory removal | complete | No | delivery-process/recipes/ (delete) |
      | CLI integration (generate-docs --generators reference-*) | complete | No | src/cli/generate-docs.ts |

  # ===========================================================================
  # Core Design: Parameterized Reference Codec
  # ===========================================================================

  @acceptance-criteria
  Rule: Reference documents are generated by a parameterized codec

    **Invariant:** Each reference document type is a configuration object, not a
    separate codec class. One `createReferenceCodec(config)` factory serves all
    11 document types.

    **Rationale:** 11 separate codec classes would just be reimplementing recipes
    in TypeScript. A parameterized codec keeps the configuration declarative
    while the composition logic is shared.

    Scenario: Generate process guard reference at standard detail level
      Given a ReferenceDocConfig for "Process Guard"
      And convention-tagged decision records exist for "fsm-rules"
      And TypeScript shapes are extracted from "src/lint/*.ts"
      When the reference codec decodes the MasterDataset
      Then a RenderableDocument is produced with Process Guard content
      And sections include convention content, API types, and validation rules

    Scenario: Generate process guard reference at summary detail level
      Given a ReferenceDocConfig for "Process Guard" with detailLevel "summary"
      When the reference codec decodes the MasterDataset
      Then the output uses tables over prose
      And type names are listed without full definitions
      And no duplicate sections appear
      And output is under 100 lines

  # ===========================================================================
  # Convention Extraction from Decision Records
  # ===========================================================================

  @acceptance-criteria
  Rule: Convention content is extracted from tagged decision records

    **Invariant:** Decision records tagged with `@libar-docs-convention` are the
    source of truth for durable reference content. The extractor filters by
    convention tag value and extracts Rule block content.

    **Rationale:** Recipe Rule blocks contain durable knowledge (tables, context,
    rationale) that belongs in decision records — permanent, queryable, tagged.
    Decision records are already extracted as patterns in MasterDataset.

    Scenario: Extract conventions by tag value
      Given ADR-006 is tagged with "@libar-docs-convention:fsm-rules"
      And ADR-004 is tagged with "@libar-docs-convention:testing-policy"
      When extracting conventions for "fsm-rules"
      Then only ADR-006 Rule block content is returned
      And ADR-004 content is not included

    Scenario: Convention content preserves Rule block structure
      Given a decision record with Rule blocks containing tables and context
      When extracting convention content
      Then tables are preserved as structured data
      And Invariant/Rationale/Verified-by metadata is preserved

  # ===========================================================================
  # Edge Cases and Graceful Degradation
  # ===========================================================================

  @acceptance-criteria
  Rule: Reference codec handles missing or empty sources gracefully

    **Invariant:** When convention tags, shape sources, or behavior tags match
    zero items in the MasterDataset, the codec produces a valid but sparse
    document rather than failing.

    **Rationale:** Not all reference configs will have all three source types
    populated. Some references have no shapes (Session Guides), others have
    no conventions yet (before migration). Graceful degradation is required.

    @validation
    Scenario: No conventions found for requested tag values
      Given a MasterDataset with no decision records tagged "fsm-rules"
      When the reference codec decodes for "Process Guard"
      Then the output omits the conventions section
      And the document is still valid with shape and behavior content

    @validation
    Scenario: No shape sources match any pattern file paths
      Given a ReferenceDocConfig with shapeSources "src/nonexistent/*.ts"
      When the reference codec decodes the MasterDataset
      Then the output omits the type definitions section
      And no error is raised

    @edge-case
    Scenario: Convention tag matches multiple decision records
      Given ADR-006 and ADR-012 are both tagged "fsm-rules"
      When extracting conventions for "fsm-rules"
      Then both decision records contribute Rule block content
      And content is ordered by source decision record

  # ===========================================================================
  # Dual Output: docs/ and _claude-md/
  # ===========================================================================

  @acceptance-criteria
  Rule: Each reference generator produces dual output via DetailLevel

    **Invariant:** A single ReferenceDocConfig drives both the detailed human
    reference (docs/) and the compact AI context (_claude-md/). The
    ReferenceDocGenerator invokes the codec factory twice with different
    DetailLevel values, following the DecisionDocGeneratorImpl multi-level pattern.

    **Rationale:** The recipe system declared dual targets in its Target Documents
    table. The generator approach achieves the same by running the same codec with
    different options. No separate configuration needed.

    **Verified by:** Dual output generation, Summary compaction quality

    Scenario: Dual output generation
      Given a ReferenceDocConfig with claudeMdSection "validation"
      When the reference generator runs
      Then "docs/PROCESS-GUARD-REFERENCE.md" is generated at "detailed" level
      And "_claude-md/validation/process-guard.md" is generated at "summary" level

    @validation
    Scenario: Summary compaction quality
      Given a reference codec output at "summary" detail level
      Then the output follows modular-claude-md conventions
      And headings start at H3 level
      And tables are preferred over prose
      And total output is under 100 lines

  # ===========================================================================
  # Generator Registration
  # ===========================================================================

  @acceptance-criteria
  Rule: Reference generators are discovered via the existing registry

    **Invariant:** Reference generators register themselves in the GeneratorRegistry
    by implementing DocumentGenerator directly, following the DecisionDocGeneratorImpl
    precedent. DOCUMENT_TYPES is `as const` and not dynamically extensible, so the
    CodecBasedGenerator adapter is not used.

    **Rationale:** DecisionDocGeneratorImpl already demonstrates this pattern:
    direct DocumentGenerator implementation, dual output, factory function registration.
    No changes needed to generate.ts, codec-based.ts, or registry.ts.

    Scenario: Reference generators appear in available generators list
      Given reference generators are registered
      When querying GeneratorRegistry.available()
      Then "process-guard-reference" is listed
      And "session-guides-reference" is listed
      And all 11 reference types are available

    Scenario: CLI invocation generates reference docs
      Given the generate-docs CLI
      When running with "--generators process-guard-reference"
      Then dual output is produced for process guard

  # ===========================================================================
  # Convention Taxonomy
  # ===========================================================================

  @acceptance-criteria
  Rule: Convention tag values classify decision records by topic

    **Invariant:** The `@libar-docs-convention` tag uses CSV format with defined
    values. Each value maps to a knowledge domain that reference codecs consume.

    **Rationale:** Convention tags are orthogonal to existing `@libar-docs-adr-category`
    (which is too coarse — "process" covers both testing policy and FSM rules).

    | Value | Knowledge Domain | Reference Docs That Consume |
    | --- | --- | --- |
    | testing-policy | Test safety, Gherkin-only policy | GherkinPatternsReference, ValidationReference |
    | fsm-rules | FSM transitions, protection levels | ProcessGuardReference, SessionGuidesReference |
    | cli-patterns | CLI conventions, arg parsing | InstructionsReference, ConfigurationReference |
    | output-format | Text vs markdown, codec patterns | ArchitectureReference |
    | pattern-naming | Pattern identifiers, @implements | InstructionsReference, MethodologyReference |
    | session-workflow | Session types, handoff, stubs | SessionGuidesReference, MethodologyReference |
    | config-presets | Presets, tag prefixes, RegexBuilders | ConfigurationReference |
    | annotation-system | Tag formats, dual-source, opt-in | InstructionsReference, TaxonomyReference |
    | pipeline-architecture | Four-stage pipeline, codecs, MasterDataset | ArchitectureReference |
    | publishing | Publishing strategy, versioning | PublishingReference |
    | doc-generation | Recipes, generators, dual output | IndexReference |

    Scenario: Convention tag is registered in taxonomy
      Given the tag registry
      When checking for "@libar-docs-convention"
      Then it exists with format "csv"
      And it accepts the defined convention values

  # ===========================================================================
  # Migration Validation
  # ===========================================================================

  @acceptance-criteria
  Rule: Recipe Rule blocks are migrated to convention-tagged decision records

    **Invariant:** Every Rule block from the 11 recipe .feature files is
    preserved as a Rule block in a decision record tagged with the appropriate
    `@libar-docs-convention` value. No durable content is lost during migration.

    **Rationale:** Recipe Rule blocks contain tables, rationale, and context
    that are the authoritative reference for the delivery process. Migration
    must be lossless.

    Scenario: Recipe Rule block content preserved in decision record
      Given recipe "process-guard-reference.feature" has Rule "Escape Hatches"
      And the Rule contains a table with "Situation", "Solution", "Example" columns
      When the Rule is migrated to a decision record tagged "fsm-rules"
      Then the decision record Rule block contains the same table
      And Invariant/Rationale metadata is preserved
