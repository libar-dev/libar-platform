/**
 * Unit Tests for ID Generation Utilities
 *
 * Tests pure functions in ids/generator.ts:
 * - generateId: Prefixed ID generation
 * - parseId: ID parsing
 * - generateCorrelationId: Correlation ID generation
 * - generateCommandId: Command ID generation
 * - generateEventId: Event ID generation
 */
import { describe, it, expect } from "vitest";
import {
  generateId,
  parseId,
  generateCorrelationId,
  generateCommandId,
  generateEventId,
  generateIntegrationEventId,
} from "../../../src/ids/generator";

describe("generateId", () => {
  it("generates ID with correct format: {context}_{type}_{uuid}", () => {
    const id = generateId("orders", "order");

    expect(id).toMatch(/^orders_order_[0-9a-f-]{36}$/);
  });

  it("generates unique IDs on each call", () => {
    const id1 = generateId("orders", "order");
    const id2 = generateId("orders", "order");

    expect(id1).not.toBe(id2);
  });

  it("uses provided context and type", () => {
    const id = generateId("inventory", "product");

    expect(id.startsWith("inventory_product_")).toBe(true);
  });

  it("throws error for empty context", () => {
    expect(() => generateId("", "order")).toThrow("context cannot be empty");
  });

  it("throws error for empty type", () => {
    expect(() => generateId("orders", "")).toThrow("type cannot be empty");
  });

  it("throws error for context with underscore", () => {
    expect(() => generateId("orders_context", "order")).toThrow(
      /Invalid context.*Must contain only lowercase letters and numbers/
    );
  });

  it("throws error for type with underscore", () => {
    expect(() => generateId("orders", "order_type")).toThrow(
      /Invalid type.*Must contain only lowercase letters and numbers/
    );
  });

  it("throws error for context with uppercase", () => {
    expect(() => generateId("Orders", "order")).toThrow(/Invalid context/);
  });

  it("throws error for context with special characters", () => {
    expect(() => generateId("orders!", "order")).toThrow(/Invalid context/);
  });

  it("throws error for context with spaces", () => {
    expect(() => generateId("my orders", "order")).toThrow(/Invalid context/);
  });

  it("accepts lowercase alphanumeric context", () => {
    const id = generateId("orders123", "order");
    expect(id.startsWith("orders123_order_")).toBe(true);
  });

  it("accepts lowercase alphanumeric type", () => {
    const id = generateId("orders", "order123");
    expect(id.startsWith("orders_order123_")).toBe(true);
  });
});

describe("parseId", () => {
  it("parses valid ID into components", () => {
    const id = "orders_order_0190a7c4-1234-7abc-8def-1234567890ab";
    const result = parseId(id);

    expect(result).toEqual({
      context: "orders",
      type: "order",
      uuid: "0190a7c4-1234-7abc-8def-1234567890ab",
    });
  });

  it("parses ID generated by generateId", () => {
    const id = generateId("inventory", "product");
    const result = parseId(id);

    expect(result).not.toBeNull();
    expect(result!.context).toBe("inventory");
    expect(result!.type).toBe("product");
    expect(result!.uuid).toMatch(/^[0-9a-f-]{36}$/);
  });

  it("returns null for ID with less than 3 parts", () => {
    expect(parseId("orders")).toBeNull();
    expect(parseId("orders_order")).toBeNull();
  });

  it("returns null for empty string", () => {
    expect(parseId("")).toBeNull();
  });

  it("handles UUID containing underscores (edge case)", () => {
    // UUID v7 doesn't have underscores, but the parser should handle it
    const id = "orders_order_uuid_with_extra_parts";
    const result = parseId(id);

    expect(result).toEqual({
      context: "orders",
      type: "order",
      uuid: "uuid_with_extra_parts",
    });
  });

  it("returns null for ID with empty context", () => {
    expect(parseId("_order_uuid")).toBeNull();
  });

  it("returns null for ID with empty type", () => {
    expect(parseId("orders__uuid")).toBeNull();
  });
});

describe("generateCorrelationId", () => {
  it("generates correlation ID with corr_ prefix", () => {
    const id = generateCorrelationId();

    expect(id).toMatch(/^corr_[0-9a-f-]{36}$/);
  });

  it("generates unique correlation IDs", () => {
    const id1 = generateCorrelationId();
    const id2 = generateCorrelationId();

    expect(id1).not.toBe(id2);
  });
});

describe("generateCommandId", () => {
  it("generates command ID with cmd_ prefix", () => {
    const id = generateCommandId();

    expect(id).toMatch(/^cmd_[0-9a-f-]{36}$/);
  });

  it("generates unique command IDs", () => {
    const id1 = generateCommandId();
    const id2 = generateCommandId();

    expect(id1).not.toBe(id2);
  });
});

describe("generateEventId", () => {
  it("generates event ID with context_event_ prefix", () => {
    const id = generateEventId("orders");

    expect(id).toMatch(/^orders_event_[0-9a-f-]{36}$/);
  });

  it("uses provided context", () => {
    const id = generateEventId("inventory");

    expect(id.startsWith("inventory_event_")).toBe(true);
  });

  it("generates unique event IDs", () => {
    const id1 = generateEventId("orders");
    const id2 = generateEventId("orders");

    expect(id1).not.toBe(id2);
  });

  it("throws error for invalid context", () => {
    expect(() => generateEventId("")).toThrow("context cannot be empty");
  });
});

describe("generateIntegrationEventId", () => {
  it("generates integration event ID with int_evt_ prefix", () => {
    const id = generateIntegrationEventId();

    expect(id).toMatch(/^int_evt_[0-9a-f-]{36}$/);
  });

  it("generates unique integration event IDs", () => {
    const id1 = generateIntegrationEventId();
    const id2 = generateIntegrationEventId();

    expect(id1).not.toBe(id2);
  });
});

describe("UUID v7 format", () => {
  it("generated UUIDs have correct format", () => {
    const id = generateId("test", "item");
    const parsed = parseId(id);

    // UUID v7 format: xxxxxxxx-xxxx-7xxx-xxxx-xxxxxxxxxxxx
    // The 7 indicates version 7
    expect(parsed!.uuid).toMatch(/^[0-9a-f]{8}-[0-9a-f]{4}-7[0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12}$/);
  });

  it("generated UUIDs are time-ordered", () => {
    // UUID v7 embeds timestamp, so sequential generation should produce sortable IDs
    const ids: string[] = [];
    for (let i = 0; i < 10; i++) {
      ids.push(generateId("test", "item"));
    }

    // UUIDs should be sortable by their string representation (lexicographic)
    const sorted = [...ids].sort();

    // Due to time ordering in UUID v7, the sorted array should match original order
    // (assuming they're generated quickly enough to have same or increasing timestamps)
    expect(ids).toEqual(sorted);
  });
});
