/**
 * Agent Action Handler Factory — Action/Mutation Split Pattern
 *
 * Creates the ACTION half of the Workpool action/mutation split.
 * The action handler:
 * - Loads state via ctx.runQuery (cannot write to DB)
 * - Checks idempotency via checkpoint position (best-effort)
 * - Runs the pattern executor for event analysis and command routing
 * - Returns AgentActionResult (NO persistence)
 *
 * All persistence happens in the onComplete mutation (see oncomplete-handler.ts).
 *
 * Design decisions:
 * - AD-1: Unified action model — all agents use actions, even rule-only ones
 * - AD-4: Explicit injectedData separates projection data from event history
 * - AD-8: Separate factory from onComplete handler
 *
 * @module agent/action-handler
 */

import type { PublishedEvent } from "../eventbus/types.js";
import type { Logger } from "../logging/types.js";
import { createPlatformNoOpLogger } from "../logging/scoped.js";
import type {
  AgentBCConfig,
  AgentDecision,
  AgentExecutionContext,
  AgentCheckpointState,
} from "./types.js";
import type { AgentCheckpoint } from "./checkpoint.js";
import type { AgentEventHandlerArgs } from "./init.js";
import type { AgentRuntimeConfig } from "./init.js";
import { executePatterns } from "./pattern-executor.js";

// ============================================================================
// State Loading Types
// ============================================================================

/**
 * Callback for loading agent state inside an action.
 *
 * Actions cannot use `ctx.db` — they must use `ctx.runQuery()` to load
 * state from agent component and app-level projections.
 *
 * Each agent provides its own loadState implementation at the app level,
 * giving it access to component APIs and app-level query handlers.
 *
 * @typeParam TCtx - The action context type (e.g., Convex ActionCtx)
 *
 * @example
 * ```typescript
 * const loadState: AgentStateLoader<ActionCtx> = async (ctx, args) => {
 *   const checkpoint = await ctx.runQuery(
 *     components.agentBC.checkpoints.getByAgentAndSubscription,
 *     { agentId: args.agentId, subscriptionId: args.subscriptionId }
 *   );
 *   return {
 *     checkpoint,
 *     eventHistory: [],
 *     injectedData: {
 *       customerCancellationHistory: await ctx.runQuery(
 *         api.projections.customerCancellations.getByCustomerId,
 *         { customerId: extractCustomerId(args) }
 *       ),
 *     },
 *   };
 * };
 * ```
 */
export type AgentStateLoader<TCtx = unknown> = (
  ctx: TCtx,
  args: AgentEventHandlerArgs
) => Promise<AgentActionState>;

/**
 * State loaded by the action for pattern detection.
 *
 * Replaces the mutation-era pattern of loading from `ctx.db` directly.
 * The loadState callback populates this via `ctx.runQuery()` calls.
 */
export interface AgentActionState {
  /**
   * Agent checkpoint (position tracking).
   * Null if this is the agent's first event.
   */
  readonly checkpoint: AgentCheckpoint | null;

  /**
   * Event history within the pattern window.
   * Contains ONLY real PublishedEvents from the event stream.
   * No projection-derived fake events.
   *
   * May be empty if the agent only uses injectedData (projection-based patterns).
   */
  readonly eventHistory: readonly PublishedEvent[];

  /**
   * Cross-component projection data loaded via ctx.runQuery.
   * Type-erased at the platform level. Each agent casts to its specific type.
   *
   * @example
   * ```typescript
   * // In churn-risk agent's pattern trigger:
   * const data = ctx.injectedData as ChurnRiskInjectedData;
   * const cancellations = data.customerCancellationHistory;
   * ```
   */
  readonly injectedData: Record<string, unknown>;
}

// ============================================================================
// Action Result Types
// ============================================================================

/**
 * Result returned by the agent action handler.
 *
 * This is the `returnValue` in Workpool's onComplete callback:
 * `result: { kind: "success", returnValue: AgentActionResult }`
 *
 * The action returns the analysis result. All persistence happens
 * in the onComplete mutation.
 */
export interface AgentActionResult {
  /**
   * Unique decision ID generated by the action handler.
   *
   * Used for idempotent persistence in onComplete:
   * - Audit recording is idempotent by decisionId
   * - Command recording is keyed by decisionId
   * - Approval creation is correlated by decisionId
   *
   * Format: `dec_${agentId}_${globalPosition}` (deterministic, replayable)
   */
  readonly decisionId: string;

  /**
   * Decision made by the agent, or null if no pattern detected.
   * Uses the existing AgentDecision type from types.ts.
   */
  readonly decision: AgentDecision | null;

  /**
   * How the decision was reached.
   *
   * - "llm": LLM was called and produced the analysis
   * - "rule-based": Pure rule-based analysis (no LLM configured or needed)
   */
  readonly analysisMethod: "llm" | "rule-based";

  /**
   * Which pattern produced this result (DS-4, PDR-012 AD-6).
   */
  readonly patternId?: string;

  /**
   * LLM call metrics for cost tracking and audit.
   * Only present when analysisMethod is "llm".
   */
  readonly llmMetrics?: {
    /** Model identifier (e.g., "anthropic/claude-sonnet-4-5-20250929") */
    readonly model: string;
    /** Total tokens consumed */
    readonly tokens: number;
    /** LLM call duration in milliseconds */
    readonly durationMs: number;
    /** @convex-dev/agent thread ID if thread-per-customer model used */
    readonly threadId?: string;
  };

  /**
   * Error message. Reserved for future use.
   */
  readonly error?: string;
}

// ============================================================================
// Factory Configuration
// ============================================================================

/**
 * Configuration for the agent action handler factory.
 *
 * The factory creates a handler function that:
 * 1. Calls loadState to get checkpoint + history + injectedData
 * 2. Checks idempotency (best-effort, not atomic)
 * 3. Creates AgentExecutionContext
 * 4. Runs pattern executor for event analysis
 * 5. Returns AgentActionResult (no persistence)
 *
 * @typeParam TCtx - The action context type (e.g., Convex ActionCtx)
 */
export interface AgentActionHandlerConfig<TCtx = unknown> {
  /**
   * Agent BC configuration.
   * Contains patterns, subscriptions, patternWindow, etc.
   */
  readonly agentConfig: AgentBCConfig;

  /**
   * LLM runtime for analysis.
   * Required — agents must have a configured runtime.
   * Use createMockAgentRuntime() explicitly in unit tests.
   */
  readonly runtime: AgentRuntimeConfig;

  /**
   * State loading callback.
   * Called inside the action to load checkpoint, history, and injected data.
   * Uses ctx.runQuery() to access component APIs and app-level queries.
   *
   * Each agent provides its own implementation at the app level.
   */
  readonly loadState: AgentStateLoader<TCtx>;

  /**
   * Logger instance.
   */
  readonly logger?: Logger;
}

// ============================================================================
// Factory Function
// ============================================================================

/**
 * Create an agent action handler for LLM-integrated event processing.
 *
 * Returns the handler function (NOT a registered internalAction -- registration
 * happens at the app level using `internalAction({ args, handler })`).
 *
 * Flow:
 * 1. Load state via loadState callback (ctx.runQuery)
 * 2. Check idempotency via checkpoint position
 * 3. Check agent active status
 * 4. Reconstruct PublishedEvent from args
 * 5. Build AgentExecutionContext with injectedData
 * 6. Execute patterns via executePatterns(config.agentConfig.patterns, ...)
 * 7. Return AgentActionResult (no persistence!)
 *
 * @typeParam TCtx - The action context type (e.g., Convex ActionCtx)
 * @param config - Action handler configuration
 * @returns Handler function to wrap in internalAction
 *
 * @example
 * ```typescript
 * const handler = createAgentActionHandler({
 *   agentConfig: churnRiskAgentConfig,
 *   runtime: createOpenRouterRuntime(apiKey),
 *   loadState: async (ctx, args) => ({
 *     checkpoint: await ctx.runQuery(
 *       components.agentBC.checkpoints.getByAgentAndSubscription,
 *       { agentId: args.agentId }
 *     ),
 *     eventHistory: [],
 *     injectedData: { ... },
 *   }),
 * });
 *
 * // Register at the app level:
 * export const analyzeEvent = internalAction({ args: { ... }, handler });
 * ```
 */
export function createAgentActionHandler<TCtx = unknown>(
  config: AgentActionHandlerConfig<TCtx>
): (ctx: TCtx, args: AgentEventHandlerArgs) => Promise<AgentActionResult | null> {
  const logger = config.logger ?? createPlatformNoOpLogger();

  return async (ctx: TCtx, args: AgentEventHandlerArgs): Promise<AgentActionResult | null> => {
    // 1. Load state via the app-level loadState callback
    const state = await config.loadState(ctx, args);

    // 2. Idempotency check (best-effort -- not atomic in an action)
    if (state.checkpoint && args.globalPosition <= state.checkpoint.lastProcessedPosition) {
      logger.debug("Event already processed, skipping", {
        agentId: args.agentId,
        eventId: args.eventId,
        eventPosition: args.globalPosition,
        checkpointPosition: state.checkpoint.lastProcessedPosition,
      });
      return null;
    }

    // 3. Check agent active status
    if (state.checkpoint && state.checkpoint.status !== "active") {
      logger.debug("Agent is not active, skipping", {
        agentId: args.agentId,
        status: state.checkpoint.status,
      });
      return null;
    }

    // 4. Reconstruct PublishedEvent from handler args
    const event: PublishedEvent = {
      eventId: args.eventId,
      eventType: args.eventType,
      globalPosition: args.globalPosition,
      streamType: args.streamType,
      streamId: args.streamId,
      payload: args.payload,
      timestamp: args.timestamp,
      category: args.category as PublishedEvent["category"],
      boundedContext: args.boundedContext,
      schemaVersion: 1,
      correlation: {
        correlationId: args.correlationId,
        causationId: args.eventId,
      },
    };

    // 5. Build execution context with injectedData
    const checkpointState: AgentCheckpointState = state.checkpoint
      ? {
          lastProcessedPosition: state.checkpoint.lastProcessedPosition,
          lastEventId: state.checkpoint.lastEventId,
          eventsProcessed: state.checkpoint.eventsProcessed,
        }
      : {
          lastProcessedPosition: -1,
          lastEventId: "",
          eventsProcessed: 0,
        };

    // Build AgentInterface from runtime (required)
    const agentInterface = {
      analyze: config.runtime.analyze,
      reason: config.runtime.reason,
    };

    // Build the execution context. The injectedData field is added beyond
    // the base AgentExecutionContext type for the action handler pattern.
    const executionContext: AgentExecutionContext & {
      readonly injectedData: Record<string, unknown>;
    } = {
      agent: agentInterface,
      history: [...state.eventHistory],
      checkpoint: checkpointState,
      config: config.agentConfig,
      injectedData: state.injectedData,
    };

    // 6. Detect patterns / call event handler
    let decision: AgentDecision | null = null;
    let analysisMethod: AgentActionResult["analysisMethod"] = "rule-based";
    let patternId: string | undefined;
    let llmMetrics: AgentActionResult["llmMetrics"];
    let errorMsg: string | undefined;

    try {
      const summary = await executePatterns(
        config.agentConfig.patterns,
        [...state.eventHistory, event],
        executionContext.agent,
        config.agentConfig
      );
      decision = summary.decision;
      patternId = summary.matchedPattern ?? undefined;

      // PatternExecutionSummary and AgentActionResult share the same
      // analysisMethod union ("llm" | "rule-based")
      analysisMethod = summary.analysisMethod;
    } catch (err) {
      logger.error("Pattern executor failed", {
        agentId: args.agentId,
        eventId: args.eventId,
        error: err instanceof Error ? err.message : String(err),
      });
      // Let Workpool retry handle this
      throw err;
    }

    // 8. Build and return result (NO persistence -- that's onComplete's job)
    const decisionId = `dec_${args.agentId}_${args.globalPosition}`;

    return {
      decisionId,
      decision,
      analysisMethod,
      ...(patternId ? { patternId } : {}),
      ...(llmMetrics ? { llmMetrics } : {}),
      ...(errorMsg ? { error: errorMsg } : {}),
    };
  };
}
