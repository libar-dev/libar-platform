/**
 * Shared Types for Agent Handler Factories
 *
 * Consolidates types used across multiple agent handler modules:
 * - AgentComponentAPI: unified component API interface
 * - RunMutationCtx: minimal mutation context for type assertions
 * - getAgentSubscriptionId: deterministic subscription ID helper
 *
 * These types were previously duplicated across oncomplete-handler.ts,
 * command-bridge.ts, and lifecycle-handlers.ts.
 *
 * @module agent/handler-types
 */

import type { FunctionReference } from "convex/server";

// ============================================================================
// Agent Component API Interface
// ============================================================================

/**
 * Unified API interface for the agent Convex component.
 *
 * All consumers (onComplete handler, lifecycle handlers, command bridge)
 * use this single interface. Each consumer accesses only the subset it needs.
 * TypeScript structural typing ensures type safety without requiring separate
 * interfaces.
 *
 * The FunctionReference types are `unknown` to avoid TS2589 deep type
 * instantiation errors. At the app level, the actual typed references are
 * passed in and Convex validates args at runtime.
 */
export interface AgentComponentAPI {
  /** Checkpoint API -- ctx.runMutation(components.agentBC.checkpoints.*) */
  readonly checkpoints: {
    /** Idempotent load-or-create for first-event handling */
    readonly loadOrCreate: FunctionReference<"mutation">;
    /** Advance checkpoint position after successful processing */
    readonly update: FunctionReference<"mutation">;
    /** Atomic lifecycle transition: update status + record audit in single mutation */
    readonly transitionLifecycle: FunctionReference<"mutation">;
    /** Patch config overrides for all agent checkpoints */
    readonly patchConfigOverrides?: FunctionReference<"mutation">;
  };

  /** Audit API -- ctx.runMutation(components.agentBC.audit.*) */
  readonly audit: {
    /** Record an audit event (idempotent by decisionId) */
    readonly record: FunctionReference<"mutation">;
  };

  /** Commands API -- ctx.runMutation(components.agentBC.commands.*) */
  readonly commands: {
    /** Record a command emitted by an agent */
    readonly record: FunctionReference<"mutation">;
    /** Update command status (optional -- used by command bridge) */
    readonly updateStatus?: FunctionReference<"mutation">;
  };

  /** Approvals API -- ctx.runMutation(components.agentBC.approvals.*) */
  readonly approvals: {
    /** Create a pending approval request */
    readonly create: FunctionReference<"mutation">;
  };

  /** Dead Letters API -- ctx.runMutation(components.agentBC.deadLetters.*) */
  readonly deadLetters: {
    /** Record a dead letter for failed event processing */
    readonly record: FunctionReference<"mutation">;
  };
}

// ============================================================================
// Minimal Mutation Context
// ============================================================================

/**
 * Minimal interface for ctx.runMutation used via type assertion.
 *
 * The handler factories are platform-agnostic (TCtx = unknown), so we cast
 * to this interface when calling component mutations. At the app level,
 * the actual Convex MutationCtx satisfies this interface.
 *
 * The `scheduler` field is optional because only the onComplete handler
 * needs it (to schedule command routing via runAfter). The command bridge
 * and lifecycle handlers use only `runMutation`.
 */
export interface RunMutationCtx {
  runMutation<T>(ref: FunctionReference<"mutation">, args: Record<string, unknown>): Promise<T>;
  scheduler?: {
    runAfter(
      delayMs: number,
      ref: FunctionReference<"mutation">,
      args: Record<string, unknown>
    ): Promise<void>;
  };
}

// ============================================================================
// Subscription ID Helper
// ============================================================================

/**
 * Generate a deterministic subscription ID for an agent.
 *
 * Used consistently across lifecycle handlers, action handlers, and onComplete.
 * The subscription ID is a simple deterministic string derived from the agentId,
 * distinct from the time-stamped subscription ID generated by `generateSubscriptionId`
 * in init.ts (which includes a timestamp + random suffix for uniqueness).
 *
 * @param agentId - Agent BC identifier
 * @returns Deterministic subscription ID in the form `sub_{agentId}`
 */
export function getAgentSubscriptionId(agentId: string): string {
  return `sub_${agentId}`;
}
